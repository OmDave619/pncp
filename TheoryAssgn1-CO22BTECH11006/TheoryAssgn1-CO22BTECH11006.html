<!DOCTYPE html>
<html>
<head>
<title>TheoryAssgn1-CO22BTECH11006.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="pncp---theory-assignment-1">PNCP - Theory Assignment 1</h1>
<h2 id="co22btech11006">CO22BTECH11006</h2>
<h2 id="om-dave">OM DAVE</h2>
<h3 id="problem-1">Problem 1</h3>
<p><img src="image.png" alt="alt text"></p>
<p>(a) <strong>Amdahl's Law:</strong></p>
<p>$$
S = \frac{1}{s + \frac{p}{n}}
$$</p>
<p>Where:</p>
<ul>
<li><strong>S</strong> is the maximum speedup,</li>
<li><strong>s</strong> is the serial fraction of the program (non-parallelizable),</li>
<li><strong>p</strong> is the parallelizable fraction,</li>
<li><strong>n</strong> is the number of processors.</li>
</ul>
<p>The formula simplifies to:</p>
<p>$$
S = \frac{1}{0.3 + \frac{0.7}{n}}
$$</p>
<p>for an n-processor machine.</p>
<p>As $n$ approaches infinity (Theoritical Maximum limit) ($n \to \infty$), the term $\frac{0.7}{n}$ approaches 0, leading to:</p>
<p>$$
S \approx \frac{1}{0.3} \approx 3.33
$$</p>
<p>Thus, the theoretical maximum speedup that can be achieved, regardless of the number of processors, is approximately 3.33.</p>
<p>(b) If M takes t time, then making it k-fold faster, it would take t/k, time, now Since, M
take 0.4 of the unit time, after speed up it would take 0.4/k time. For a system with N processors, the overall speed up is given by:</p>
<p>$$
\frac{1}{\frac{0.4}{k} + \frac{0.6}{N}} = 2
$$</p>
<p>Rearrange to solve for k:</p>
<p>$$
k \cdot N = 0.8 \cdot N + 1.2 \cdot k
$$</p>
<p>$$
k = \frac{0.8 \cdot N}{N - 1.2}
$$</p>
<p>(c) Let <strong>s</strong> be the serial fraction of the program that method M accounts for. Then the parallel fraction of the program is $1 - s$. With a 4-fold speedup for M in an $n$-processor system, the overall speedup is given by:</p>
<p>$$
2 = \frac{1}{\frac{s}{4} + \frac{1 - s}{n}}
$$</p>
<p>$$
\frac{1}{2} = \frac{s}{4} + \frac{1 - s}{n}
$$</p>
<p>$$
s = \frac{2n - 4}{n - 4}
$$</p>
<h3 id="problem-2">Problem 2</h3>
<p><img src="image-1.png" alt="alt text">
<img src="image-2.png" alt="alt text"></p>
<h4 id="solution">Solution:</h4>
<p><strong>Claim: The revised algorithm is deadlock-free.</strong></p>
<p><strong>Explanation:</strong> Possible scenarios of deadlock are:</p>
<ol>
<li>
<p><strong>When both threads are stuck while acquiring a lock.</strong> This is impossible as due to the correctness of the Peterson lock algorithm; due to the presence of a victim, only one thread is able to enter the critical section, and due to the presence of a flag, at least one thread is able to enter. This always ensures progress in the system.</p>
</li>
<li>
<p><strong>When both threads are stuck while unlocking.</strong> Let thread A be stuck in the unlock loop. At this moment, flag[A] is false, and flag[B] is true. Since flag[A] is false, this means that B, if trying to enter the critical section, would immediately be able to do so. Also, flag[B] is true, which means B is inside the critical section. Now, as soon as B leaves, it sets its flag to false and starts executing the while loop, i.e., while(flag[A] == true) {}. At this moment, the flags of both threads are false, and there is no way to make them true unless one of them exits the unlock method. As both flags are false, at least one of them will leave the unlock method, which contradicts our statement that both of them are stuck at unlock.</p>
</li>
<li>
<p><strong>When one thread is stuck at unlocking and the other is trying to acquire a lock.</strong> Consider the case when thread A is stuck at unlock with its flag false and flag[B] is true. Now, when B tries to enter, it would see the flag of A, which is false. Since A is already stuck, there is no way that this flag becomes true, which means that B could enter the critical section (breaking the while loop as flag[A] = false), and then subsequently execute unlock leading to case 2, which is also deadlock-free.</p>
</li>
</ol>
<p>So, in any scenario, progress is always possible, so the algorithm is deadlock-free.</p>
<p><strong>Claim: The algorithm is not starvation-free.</strong></p>
<p><strong>Explanation:</strong> Consider this scenario:</p>
<p>Let thread A be stuck in the unlock loop. At this moment, flag[A] is false, and flag[B] is true. Since flag[A] is false, this means that B, if trying to enter the critical section, would immediately be able to do so. Also, flag[B] is true, which means B is inside the critical section. Now, as soon as B leaves, it sets its flag to false and starts executing the while loop, i.e., while(flag[A] == true) {}. At this moment, the flags of both threads are false, and both can exit the unlock method. Now, it could be possible that before A exits its unlock method, thread B exits its unlock, enters the lock method, and sets its flag to true. This makes A unable to exit the unlock method. Also, since flag[A] is still false, B could enter the critical section again. This process could repeatedly happen such that B is re-entering the critical section while A is waiting to exit the unlock method. This could lead to starvation of a particular thread, as in this case thread A.</p>
<h3 id="problem-3">Problem 3</h3>
<p><img src="image-3.png" alt="alt text">
<img src="image-4.png" alt="alt text">
<img src="image-5.png" alt="alt text"></p>
<h4 id="solution">Solution:</h4>
<h4 id="linearization-point-at-line-15">Linearization Point at Line 15</h4>
<p>In the <code>enq()</code> method, line 15 involves the operation <code>tail.getAndIncrement()</code>. To demonstrate the non-linearity at this point, consider a scenario where two threads, Thread A and Thread B, are involved. Thread A calls <code>enq(x)</code> and Thread B calls <code>enq(y)</code>. If Thread A executes <code>tail.getAndIncrement()</code> first and receives a value of 0, followed by Thread B which executes the same method and receives the value 1, and then Thread B completes its enqueue operation before Thread A, the final state of the queue does not reflect the order in which these threads accessed the tail. This scenario shows that the operations by Thread A and Thread B on line 15 are not linearized according to the order in which they were executed, so line 15 can't be linearization point.</p>
<h4 id="linearization-point-at-line-16">Linearization Point at Line 16</h4>
<p>On line 16, where <code>items[i].set(x)</code> is executed, If Thread A and Thread B increment the <code>tail</code> successfully but Thread B is delayed in executing <code>items[i].set(y)</code>, there exists a window where the state of the queue is inconsistent - the <code>tail</code> index is updated, but the item has not been set. This delay can lead to a situation where another operation might see an incremented <code>tail</code> but an unset item at the new tail index, further proving that the <code>enq()</code> operation does not linearize at line 16 either.</p>
<h4 id="enq-is-linearizable"><code>enq()</code> is Linearizable</h4>
<p>Given that neither line 15 nor line 16 provides a consistent linearization point and considering that these are the primary operations within the <code>enq()</code> method affecting state, it is concluded that <code>enq()</code> does not have a single linearization point. However, this does not imply that <code>enq()</code> is not linearizable. The method, when viewed as a whole within the context of the queue's operations, can still behave linearly in a broader multi-threaded environment, ensuring overall system correctness and order.</p>

</body>
</html>
